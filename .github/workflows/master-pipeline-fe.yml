name: "Master Pipeline Orchestrator"

on:
  push:
    branches: [test, uat, main]
  pull_request:
    branches: [test, uat, main]
  workflow_dispatch:
    inputs:
      pipeline_mode:
        description: "Pipeline mode (auto|single|multi)"
        type: choice
        options: [auto, single, multi]
        default: auto
      run_deploy:
        description: "Run deploy jobs"
        type: boolean
        default: true
      run_promotion:
        description: "Run PR promotion jobs"
        type: boolean
        default: true
      dry_run:
        description: "Preview-only mode (skip deploy/tag push, print PR body)"
        type: boolean
        default: false
  workflow_call:
    inputs:
      pipeline_mode:
        description: "Pipeline mode (auto|single|multi)"
        type: string
        default: auto
      run_deploy:
        description: "Run deploy jobs"
        type: boolean
        default: true
      run_promotion:
        description: "Run PR promotion jobs"
        type: boolean
        default: true
      dry_run:
        description: "Preview-only mode (skip deploy/tag push, print PR body)"
        type: boolean
        default: false

permissions:
  contents: write
  packages: write
  pull-requests: write
  security-events: write

concurrency:
  group: master-pipeline-${{ github.ref }}
  cancel-in-progress: true

jobs:
  systems-config:
    name: "Resolve Systems Configuration"
    runs-on: ubuntu-latest
    outputs:
      systems_json: ${{ steps.resolve.outputs.systems_json }}
      systems_label: ${{ steps.resolve.outputs.systems_label }}
      pipeline_mode: ${{ steps.resolve.outputs.pipeline_mode }}
    steps:
      - name: Resolve systems JSON
        id: resolve
        env:
          FE_SINGLE_SYSTEMS_JSON_VAR: ${{ vars.FE_SINGLE_SYSTEMS_JSON }}
          FE_MULTI_SYSTEMS_JSON_VAR: ${{ vars.FE_MULTI_SYSTEMS_JSON }}
          REQUESTED_PIPELINE_MODE: ${{ inputs.pipeline_mode }}
        run: |
          MODE_INPUT="${REQUESTED_PIPELINE_MODE}"
          if [ -z "${MODE_INPUT}" ]; then
            MODE_INPUT="auto"
          fi

          SYSTEMS_JSON_VAR=""
          PIPELINE_MODE=""

          if [ "${MODE_INPUT}" = "single" ]; then
            if [ -n "${FE_SINGLE_SYSTEMS_JSON_VAR}" ]; then
              SYSTEMS_JSON_VAR="${FE_SINGLE_SYSTEMS_JSON_VAR}"
            elif [ -n "${FE_MULTI_SYSTEMS_JSON_VAR}" ]; then
              SYSTEMS_JSON_VAR="${FE_MULTI_SYSTEMS_JSON_VAR}"
            fi
            PIPELINE_MODE="single"
          elif [ "${MODE_INPUT}" = "multi" ]; then
            if [ -n "${FE_MULTI_SYSTEMS_JSON_VAR}" ]; then
              SYSTEMS_JSON_VAR="${FE_MULTI_SYSTEMS_JSON_VAR}"
            elif [ -n "${FE_SINGLE_SYSTEMS_JSON_VAR}" ]; then
              SYSTEMS_JSON_VAR="${FE_SINGLE_SYSTEMS_JSON_VAR}"
            fi
            PIPELINE_MODE="multi"
          else
            if [ -n "${FE_MULTI_SYSTEMS_JSON_VAR}" ]; then
              SYSTEMS_JSON_VAR="${FE_MULTI_SYSTEMS_JSON_VAR}"
            elif [ -n "${FE_SINGLE_SYSTEMS_JSON_VAR}" ]; then
              SYSTEMS_JSON_VAR="${FE_SINGLE_SYSTEMS_JSON_VAR}"
            fi
          fi

          if [ -z "${SYSTEMS_JSON_VAR}" ]; then
            echo "‚ùå Missing required repository variable FE_MULTI_SYSTEMS_JSON or FE_SINGLE_SYSTEMS_JSON."
            exit 1
          fi

          SYSTEMS_JSON="${SYSTEMS_JSON_VAR}"

          echo "${SYSTEMS_JSON}" | jq -e . >/dev/null

          SYSTEMS_JSON_TYPE=$(echo "${SYSTEMS_JSON}" | jq -r 'type')
          if [ "${SYSTEMS_JSON_TYPE}" = "object" ]; then
            SYSTEMS_JSON=$(echo "${SYSTEMS_JSON}" | jq -c '[.]')
          elif [ "${SYSTEMS_JSON_TYPE}" = "array" ]; then
            SYSTEMS_JSON=$(echo "${SYSTEMS_JSON}" | jq -c .)
          else
            echo "‚ùå Systems JSON must be an object (single) or array (single/multi)."
            exit 1
          fi

          echo "${SYSTEMS_JSON}" | jq -e 'length > 0' >/dev/null
          echo "${SYSTEMS_JSON}" | jq -e 'all(.[]; (.name|type=="string" and length>0) and (.dir|type=="string" and length>0) and (.image|type=="string" and length>0) and (.vercel_project_secret|type=="string" and length>0))' >/dev/null

          if [ -z "${PIPELINE_MODE}" ]; then
            SYSTEMS_COUNT=$(echo "${SYSTEMS_JSON}" | jq 'length')
            if [ "${SYSTEMS_COUNT}" -gt 1 ]; then
              PIPELINE_MODE="multi"
            else
              PIPELINE_MODE="single"
            fi
          fi

          SYSTEMS_LABEL=$(echo "${SYSTEMS_JSON}" | jq -r 'map(.name) | join(", ")')

          echo "systems_json=${SYSTEMS_JSON}" >> "$GITHUB_OUTPUT"
          echo "systems_label=${SYSTEMS_LABEL}" >> "$GITHUB_OUTPUT"
          echo "pipeline_mode=${PIPELINE_MODE}" >> "$GITHUB_OUTPUT"

  active-systems:
    name: "Detect Active Systems"
    needs: [systems-config]
    runs-on: ubuntu-latest
    outputs:
      active_systems_json: ${{ steps.select.outputs.active_systems_json }}
      active_count: ${{ steps.select.outputs.active_count }}
      active_label: ${{ steps.select.outputs.active_label }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Select active systems
        id: select
        env:
          SYSTEMS_JSON: ${{ needs.systems-config.outputs.systems_json }}
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] || [ "${{ github.event_name }}" = "workflow_call" ]; then
            ACTIVE="${SYSTEMS_JSON}"
          else
            if [ "${{ github.event_name }}" = "pull_request" ]; then
              BASE_SHA="${{ github.event.pull_request.base.sha }}"
            else
              BASE_SHA="${{ github.event.before }}"
            fi

            if [ -z "${BASE_SHA}" ] || [ "${BASE_SHA}" = "0000000000000000000000000000000000000000" ]; then
              BASE_SHA=$(git rev-parse HEAD^ 2>/dev/null || git rev-parse HEAD)
            fi

            CHANGED_FILES=$(git diff --name-only "${BASE_SHA}" "${GITHUB_SHA}" || true)
            CHANGED_JSON=$(printf "%s\n" "${CHANGED_FILES}" | sed '/^$/d' | jq -R . | jq -s .)

            SHARED_CHANGED=false
            if printf "%s\n" "${CHANGED_FILES}" | grep -Eq '^(\.github/|package\.json$|sonar-project\.properties$)'; then
              SHARED_CHANGED=true
            fi

            if [ "${SHARED_CHANGED}" = "true" ]; then
              ACTIVE="${SYSTEMS_JSON}"
            else
              ACTIVE=$(echo "${SYSTEMS_JSON}" | jq -c --argjson changed "${CHANGED_JSON}" '
                map(select(
                  . as $system
                  | (($system.dir | gsub("^\\./"; "")) as $dir
                    | if ($dir == "" or $dir == ".")
                      then ($changed | length) > 0
                      else any($changed[]; startswith($dir + "/"))
                      end)
                ))
              ')
            fi
          fi

          ACTIVE=$(echo "${ACTIVE}" | jq -c '
            map(
              . + {
                version_stream: (
                  ((.version_stream // .name // .dir // "system") | ascii_downcase | gsub("[^a-z0-9]+"; "-") | gsub("(^-+|-+$)"; ""))
                  | if length > 0 then . else "system" end
                )
              }
            )
          ')

          ACTIVE_COUNT=$(echo "${ACTIVE}" | jq 'length')
          if [ "${ACTIVE_COUNT}" -gt 0 ]; then
            ACTIVE_LABEL=$(echo "${ACTIVE}" | jq -r 'map(.name) | join(", ")')
          else
            ACTIVE_LABEL="None"
          fi

          echo "active_systems_json=${ACTIVE}" >> "$GITHUB_OUTPUT"
          echo "active_count=${ACTIVE_COUNT}" >> "$GITHUB_OUTPUT"
          echo "active_label=${ACTIVE_LABEL}" >> "$GITHUB_OUTPUT"

  frontend:
    name: "Frontend ‚Äî ${{ matrix.system.name }}"
    needs: [active-systems]
    if: fromJson(needs.active-systems.outputs.active_count) > 0
    strategy:
      fail-fast: false
      matrix:
        system: ${{ fromJson(needs.active-systems.outputs.active_systems_json) }}
    uses: ./.github/workflows/front-end-workflow.yml
    with:
      system-dir: ${{ matrix.system.dir }}
      system-name: ${{ matrix.system.name }}
      enable-security-scan: true
      enable-sonar: false
    secrets: inherit

  sonarcloud:
    name: "SonarCloud ‚Äî Monorepo Analysis"
    needs: [frontend, active-systems]
    if: always() && needs.frontend.result != 'cancelled' && fromJson(needs.active-systems.outputs.active_count) > 0
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate SonarCloud project access
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_ORGANIZATION: ${{ secrets.SONAR_ORGANIZATION }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
        run: |
          if [ -z "${SONAR_TOKEN}" ] || [ -z "${SONAR_ORGANIZATION}" ] || [ -z "${SONAR_PROJECT_KEY}" ]; then
            echo "‚ùå SonarCloud preflight failed: one or more required secrets are empty."
            exit 1
          fi

          RESPONSE=$(curl -sS -w "\n%{http_code}" -u "${SONAR_TOKEN}:" "https://sonarcloud.io/api/projects/search?organization=${SONAR_ORGANIZATION}&projects=${SONAR_PROJECT_KEY}")
          HTTP_CODE=$(echo "${RESPONSE}" | tail -n 1)
          BODY=$(echo "${RESPONSE}" | sed '$d')
          TOTAL=$(echo "${BODY}" | jq -r '.paging.total // 0')

          echo "üîé Sonar preflight: org='${SONAR_ORGANIZATION}', project='${SONAR_PROJECT_KEY}', http=${HTTP_CODE}, total=${TOTAL}"

          if [ "${HTTP_CODE}" -ne 200 ] || [ "${TOTAL}" -lt 1 ]; then
            echo "‚ùå SonarCloud preflight failed: project not found or token has no access."
            echo "Check SONAR_ORGANIZATION, SONAR_PROJECT_KEY, and SONAR_TOKEN permissions for this repository."
            exit 1
          fi

          echo "‚úÖ SonarCloud preflight passed."

      - name: Run SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: https://sonarcloud.io
        with:
          args: >
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}

  version-test:
    name: "Version Tag ‚Äî TEST (${{ matrix.system.name }})"
    needs: [frontend, active-systems, sonarcloud]
    if: >-
      always() &&
      github.ref == 'refs/heads/test' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      ((github.event_name != 'workflow_dispatch' && github.event_name != 'workflow_call') || inputs.dry_run != true) &&
      fromJson(needs.active-systems.outputs.active_count) > 0 &&
      (needs.sonarcloud.result == 'success' || needs.sonarcloud.result == 'skipped') &&
      (needs.frontend.result == 'success' || needs.frontend.result == 'skipped')
    strategy:
      fail-fast: false
      matrix:
        system: ${{ fromJson(needs.active-systems.outputs.active_systems_json) }}
    uses: ./.github/workflows/versioning.yml
    with:
      mode: test
      stream: ${{ matrix.system.version_stream }}

  deploy-test:
    name: "TEST ‚Äî ${{ matrix.system.name }}"
    needs: [frontend, active-systems, sonarcloud]
    if: >-
      always() &&
      github.ref == 'refs/heads/test' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      ((github.event_name != 'workflow_dispatch' && github.event_name != 'workflow_call') || (inputs.run_deploy == true && inputs.dry_run != true)) &&
      fromJson(needs.active-systems.outputs.active_count) > 0 &&
      (needs.sonarcloud.result == 'success' || needs.sonarcloud.result == 'skipped') &&
      (needs.frontend.result == 'success' || needs.frontend.result == 'skipped')
    strategy:
      fail-fast: false
      matrix:
        system: ${{ fromJson(needs.active-systems.outputs.active_systems_json) }}
    uses: ./.github/workflows/vercel-deploy.yml
    with:
      working-directory: ${{ matrix.system.dir }}
      environment: preview
    secrets:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
      VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
      VERCEL_PROJECT_ID: ${{ secrets[matrix.system.vercel_project_secret] }}

  deploy-uat:
    name: "UAT ‚Äî ${{ matrix.system.name }}"
    needs: [frontend, active-systems, sonarcloud]
    if: >-
      always() &&
      github.ref == 'refs/heads/uat' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      ((github.event_name != 'workflow_dispatch' && github.event_name != 'workflow_call') || (inputs.run_deploy == true && inputs.dry_run != true)) &&
      fromJson(needs.active-systems.outputs.active_count) > 0 &&
      (needs.sonarcloud.result == 'success' || needs.sonarcloud.result == 'skipped') &&
      (needs.frontend.result == 'success' || needs.frontend.result == 'skipped')
    strategy:
      fail-fast: false
      matrix:
        system: ${{ fromJson(needs.active-systems.outputs.active_systems_json) }}
    uses: ./.github/workflows/vercel-deploy.yml
    with:
      working-directory: ${{ matrix.system.dir }}
      environment: preview
    secrets:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
      VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
      VERCEL_PROJECT_ID: ${{ secrets[matrix.system.vercel_project_secret] }}

  production-gate:
    name: "Production Readiness Gate"
    needs: [frontend, active-systems, sonarcloud]
    if: >-
      always() &&
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      ((github.event_name != 'workflow_dispatch' && github.event_name != 'workflow_call') || (inputs.run_deploy == true && inputs.dry_run != true)) &&
      fromJson(needs.active-systems.outputs.active_count) > 0 &&
      (needs.sonarcloud.result == 'success' || needs.sonarcloud.result == 'skipped') &&
      (needs.frontend.result == 'success' || needs.frontend.result == 'skipped')
    uses: ./.github/workflows/production-gate.yml
    with:
      system-dir: ${{ needs.active-systems.outputs.active_label }}
      app-type: web
    secrets: inherit

  deploy-prod:
    name: "Prod ‚Äî ${{ matrix.system.name }}"
    needs: [production-gate, active-systems]
    if: >-
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || ((github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') && inputs.run_deploy == true && inputs.dry_run != true)) &&
      fromJson(needs.active-systems.outputs.active_count) > 0
    strategy:
      fail-fast: false
      matrix:
        system: ${{ fromJson(needs.active-systems.outputs.active_systems_json) }}
    uses: ./.github/workflows/vercel-deploy.yml
    with:
      working-directory: ${{ matrix.system.dir }}
      environment: production
    secrets:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
      VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
      VERCEL_PROJECT_ID: ${{ secrets[matrix.system.vercel_project_secret] }}

  update-about-link:
    name: "Update Repository About Link"
    needs: [deploy-prod]
    if: >-
      always() &&
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      needs.deploy-prod.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Resolve latest production deployment URL
        id: resolve-url
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          RESPONSE=$(curl -sS -H "Authorization: Bearer ${VERCEL_TOKEN}" "https://api.vercel.com/v6/deployments?target=production&meta-githubCommitSha=${COMMIT_SHA}&limit=50")

          if ! echo "${RESPONSE}" | jq -e . >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Invalid Vercel API response; skipping About homepage update."
            exit 0
          fi

          URL=$(echo "${RESPONSE}" | jq -r '[.deployments[]? | select((.state // "") == "READY") | ("https://" + .url)] | first // ""')

          if [ -z "${URL}" ]; then
            echo "‚ö†Ô∏è No production deployment URL found for this commit; skipping About homepage update."
            exit 0
          fi

          echo "deployment_url=${URL}" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Resolved production deployment URL: ${URL}"

      - name: Update repository homepage URL
        if: ${{ steps.resolve-url.outputs.deployment_url != '' }}
        env:
          GH_PR_TOKEN_PRIMARY: ${{ secrets.GH_PR_TOKEN }}
          GH_PR_TOKEN_LEGACY: ${{ secrets.GHPR_TOKEN }}
          DEPLOYMENT_URL: ${{ steps.resolve-url.outputs.deployment_url }}
        run: |
          GH_TOKEN="${GH_PR_TOKEN_PRIMARY}"
          if [ -z "${GH_TOKEN}" ]; then
            GH_TOKEN="${GH_PR_TOKEN_LEGACY}"
          fi

          if [ -z "${GH_TOKEN}" ]; then
            echo "‚ö†Ô∏è GH_PR_TOKEN/GHPR_TOKEN is not set; skipping About homepage update."
            exit 0
          fi

          if gh api --method PATCH "repos/${{ github.repository }}" -f homepage="${DEPLOYMENT_URL}" >/dev/null 2>&1; then
            echo "‚úÖ Updated repository About homepage to ${DEPLOYMENT_URL}"
          else
            echo "‚ö†Ô∏è Failed to update repository About homepage (token may lack admin rights)."
          fi

  version-main-release:
    name: "Version Tag ‚Äî MAIN Release (${{ matrix.system.name }})"
    needs: [deploy-prod, update-about-link, active-systems]
    if: >-
      always() &&
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      ((github.event_name != 'workflow_dispatch' && github.event_name != 'workflow_call') || inputs.dry_run != true) &&
      fromJson(needs.active-systems.outputs.active_count) > 0 &&
      (needs.deploy-prod.result == 'success' || needs.deploy-prod.result == 'skipped')
    strategy:
      fail-fast: false
      matrix:
        system: ${{ fromJson(needs.active-systems.outputs.active_systems_json) }}
    uses: ./.github/workflows/versioning.yml
    with:
      mode: main
      stream: ${{ matrix.system.version_stream }}

  resolve-main-tags:
    name: "Resolve MAIN Tags"
    needs: [version-main-release, active-systems]
    if: >-
      always() &&
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      fromJson(needs.active-systems.outputs.active_count) > 0 &&
      (needs.version-main-release.result == 'success' || needs.version-main-release.result == 'skipped')
    runs-on: ubuntu-latest
    outputs:
      tags_json: ${{ steps.resolve.outputs.tags_json }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build per-system MAIN tags JSON
        id: resolve
        env:
          SYSTEMS_JSON: ${{ needs.active-systems.outputs.active_systems_json }}
        run: |
          TAGS_JSON='{}'

          while IFS=$'\t' read -r NAME STREAM; do
            if [ -z "${NAME}" ]; then
              continue
            fi

            if [ -z "${STREAM}" ] || [ "${STREAM}" = "global" ]; then
              PREFIX="main-v"
            else
              PREFIX="main-${STREAM}-v"
            fi

            TAG=$(git tag -l "${PREFIX}*" | grep -E "^${PREFIX}[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$" | sort -V | tail -n 1)
            TAGS_JSON=$(echo "${TAGS_JSON}" | jq -c --arg name "${NAME}" --arg tag "${TAG}" '. + {($name):$tag}')
          done < <(echo "${SYSTEMS_JSON}" | jq -r '.[] | "\(.name)\t\(.version_stream // "global")"')

          echo "tags_json=${TAGS_JSON}" >> "$GITHUB_OUTPUT"

  docker-main:
    name: "GHCR ‚Äî ${{ matrix.system.name }}"
    needs: [version-main-release, resolve-main-tags, active-systems]
    if: >-
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || ((github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') && inputs.run_deploy == true && inputs.dry_run != true)) &&
      fromJson(needs.active-systems.outputs.active_count) > 0
    strategy:
      fail-fast: false
      matrix:
        system: ${{ fromJson(needs.active-systems.outputs.active_systems_json) }}
    uses: ./.github/workflows/docker-build.yml
    with:
      working-directory: ${{ matrix.system.dir }}
      image-name: ${{ matrix.system.image }}
      release-tag: ${{ fromJson(needs.resolve-main-tags.outputs.tags_json)[matrix.system.name] }}
      push-image: true
      scan-vulnerabilities: true
    secrets: inherit

  prepare-promotion-test-payload:
    name: "Prepare Promotion Payload (TEST‚ÜíUAT)"
    needs: [active-systems, frontend, deploy-test]
    if: >-
      always() &&
      github.ref == 'refs/heads/test' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      fromJson(needs.active-systems.outputs.active_count) > 0 &&
      (needs.frontend.result == 'success' || needs.frontend.result == 'skipped') &&
      (needs.deploy-test.result == 'success' || needs.deploy-test.result == 'skipped')
    runs-on: ubuntu-latest
    outputs:
      deployment_urls_json: ${{ steps.build.outputs.deployment_urls_json }}
      results_json: ${{ steps.build.outputs.results_json }}
      versions_json: ${{ steps.build.outputs.versions_json }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build payload JSON
        id: build
        env:
          SYSTEMS_JSON: ${{ needs.active-systems.outputs.active_systems_json }}
          FRONTEND_RESULT: ${{ needs.frontend.result }}
          DEPLOY_RESULT: ${{ needs.deploy-test.result }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          RESPONSE=$(curl -sS -H "Authorization: Bearer ${VERCEL_TOKEN}" "https://api.vercel.com/v6/deployments?target=preview&meta-githubCommitSha=${COMMIT_SHA}&limit=100")
          if ! echo "${RESPONSE}" | jq -e . >/dev/null 2>&1; then
            RESPONSE='{"deployments":[]}'
          fi

          DEPLOYMENT_URLS_JSON=$(echo "${SYSTEMS_JSON}" | jq -c --argjson data "${RESPONSE}" --arg runUrl "${RUN_URL}" '
            reduce .[] as $s ({};
              ($s.name // "") as $name |
              ($s.dir // "" | gsub("^\\./"; "") | split("/")[0]) as $dirKey |
              ($name | ascii_downcase) as $nameLower |
              ($dirKey | ascii_downcase) as $dirLower |
              .[$name] = (
                [ $data.deployments[]?
                  | select((.state // "") == "READY")
                  | { n: ((.name // "") | ascii_downcase), u: (if (.url // "") == "" then "" else ("https://" + .url) end) }
                  | select(.u != "")
                  | select(.n == $nameLower or .n == $dirLower)
                  | .u
                ] | first // $runUrl
              )
            )
          ')

          RESULT_VALUE="${DEPLOY_RESULT}"
          if [ -z "${RESULT_VALUE}" ]; then
            RESULT_VALUE="${FRONTEND_RESULT}"
          fi
          if [ -z "${RESULT_VALUE}" ]; then
            RESULT_VALUE="unknown"
          fi

          RESULTS_JSON=$(echo "${SYSTEMS_JSON}" | jq -c --arg result "${RESULT_VALUE}" 'reduce .[] as $s ({}; .[$s.name] = $result)')

          VERSIONS_JSON=$(echo "${SYSTEMS_JSON}" | jq -c 'reduce .[] as $s ({}; .[$s.name] = "N/A")')
          MISSING_TEST_TAG=false
          while IFS=$'\t' read -r NAME STREAM; do
            if [ -z "${NAME}" ]; then
              continue
            fi

            if [ -z "${STREAM}" ] || [ "${STREAM}" = "global" ]; then
              PREFIX="test-v"
            else
              PREFIX="test-${STREAM}-v"
            fi

            TAG=$(git tag -l "${PREFIX}*" | grep -E "^${PREFIX}[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$" | sort -V | tail -n 1)
            if [ -z "${TAG}" ]; then
              echo "‚ùå Missing required ${PREFIX}<version> tag for system '${NAME}'."
              MISSING_TEST_TAG=true
              TAG="N/A"
            fi

            VERSIONS_JSON=$(echo "${VERSIONS_JSON}" | jq -c --arg name "${NAME}" --arg tag "${TAG}" '. + {($name):$tag}')
          done < <(echo "${SYSTEMS_JSON}" | jq -r '.[] | "\(.name)\t\(.version_stream // "global")"')

          if [ "${MISSING_TEST_TAG}" = "true" ]; then
            echo "‚ùå UAT‚ÜíMain promotion blocked: run TEST tagging first for all active systems/streams."
            exit 1
          fi

          echo "deployment_urls_json=${DEPLOYMENT_URLS_JSON}" >> "$GITHUB_OUTPUT"
          echo "results_json=${RESULTS_JSON}" >> "$GITHUB_OUTPUT"
          echo "versions_json=${VERSIONS_JSON}" >> "$GITHUB_OUTPUT"

  prepare-promotion-uat-payload:
    name: "Prepare Promotion Payload (UAT‚ÜíMAIN)"
    needs: [active-systems, frontend, deploy-uat]
    if: >-
      always() &&
      github.ref == 'refs/heads/uat' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      fromJson(needs.active-systems.outputs.active_count) > 0 &&
      (needs.frontend.result == 'success' || needs.frontend.result == 'skipped') &&
      (needs.deploy-uat.result == 'success' || needs.deploy-uat.result == 'skipped')
    runs-on: ubuntu-latest
    outputs:
      deployment_urls_json: ${{ steps.build.outputs.deployment_urls_json }}
      results_json: ${{ steps.build.outputs.results_json }}
      versions_json: ${{ steps.build.outputs.versions_json }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build payload JSON
        id: build
        env:
          SYSTEMS_JSON: ${{ needs.active-systems.outputs.active_systems_json }}
          FRONTEND_RESULT: ${{ needs.frontend.result }}
          DEPLOY_RESULT: ${{ needs.deploy-uat.result }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          RESPONSE=$(curl -sS -H "Authorization: Bearer ${VERCEL_TOKEN}" "https://api.vercel.com/v6/deployments?target=preview&meta-githubCommitSha=${COMMIT_SHA}&limit=100")
          if ! echo "${RESPONSE}" | jq -e . >/dev/null 2>&1; then
            RESPONSE='{"deployments":[]}'
          fi

          DEPLOYMENT_URLS_JSON=$(echo "${SYSTEMS_JSON}" | jq -c --argjson data "${RESPONSE}" --arg runUrl "${RUN_URL}" '
            reduce .[] as $s ({};
              ($s.name // "") as $name |
              ($s.dir // "" | gsub("^\\./"; "") | split("/")[0]) as $dirKey |
              ($name | ascii_downcase) as $nameLower |
              ($dirKey | ascii_downcase) as $dirLower |
              .[$name] = (
                [ $data.deployments[]?
                  | select((.state // "") == "READY")
                  | { n: ((.name // "") | ascii_downcase), u: (if (.url // "") == "" then "" else ("https://" + .url) end) }
                  | select(.u != "")
                  | select(.n == $nameLower or .n == $dirLower)
                  | .u
                ] | first // $runUrl
              )
            )
          ')

          RESULT_VALUE="${DEPLOY_RESULT}"
          if [ -z "${RESULT_VALUE}" ]; then
            RESULT_VALUE="${FRONTEND_RESULT}"
          fi
          if [ -z "${RESULT_VALUE}" ]; then
            RESULT_VALUE="unknown"
          fi

          RESULTS_JSON=$(echo "${SYSTEMS_JSON}" | jq -c --arg result "${RESULT_VALUE}" 'reduce .[] as $s ({}; .[$s.name] = $result)')

          VERSIONS_JSON=$(echo "${SYSTEMS_JSON}" | jq -c 'reduce .[] as $s ({}; .[$s.name] = "N/A")')
          while IFS=$'\t' read -r NAME STREAM; do
            if [ -z "${NAME}" ]; then
              continue
            fi

            if [ -z "${STREAM}" ] || [ "${STREAM}" = "global" ]; then
              PREFIX="test-v"
            else
              PREFIX="test-${STREAM}-v"
            fi

            TAG=$(git tag -l "${PREFIX}*" | grep -E "^${PREFIX}[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$" | sort -V | tail -n 1)
            if [ -z "${TAG}" ]; then
              TAG="N/A"
            fi

            VERSIONS_JSON=$(echo "${VERSIONS_JSON}" | jq -c --arg name "${NAME}" --arg tag "${TAG}" '. + {($name):$tag}')
          done < <(echo "${SYSTEMS_JSON}" | jq -r '.[] | "\(.name)\t\(.version_stream // "global")"')

          echo "deployment_urls_json=${DEPLOYMENT_URLS_JSON}" >> "$GITHUB_OUTPUT"
          echo "results_json=${RESULTS_JSON}" >> "$GITHUB_OUTPUT"
          echo "versions_json=${VERSIONS_JSON}" >> "$GITHUB_OUTPUT"

  create-pr-to-uat:
    name: "Create PR ‚Üí UAT"
    needs: [systems-config, frontend, sonarcloud, version-test, deploy-test, active-systems, prepare-promotion-test-payload]
    if: >-
      always() &&
      github.ref == 'refs/heads/test' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      ((github.event_name != 'workflow_dispatch' && github.event_name != 'workflow_call') || inputs.run_promotion == true) &&
      fromJson(needs.active-systems.outputs.active_count) > 0 &&
      (needs.frontend.result == 'success' || needs.frontend.result == 'skipped') &&
      needs.version-test.result == 'success' &&
      (needs.deploy-test.result == 'success' || needs.deploy-test.result == 'skipped')
    uses: ./.github/workflows/promotion.yml
    with:
      pipeline-kind: ${{ needs.systems-config.outputs.pipeline_mode }}
      direction: test-to-uat
      systems-json: ${{ needs.active-systems.outputs.active_systems_json }}
      deployment-urls-json: ${{ needs.prepare-promotion-test-payload.outputs.deployment_urls_json }}
      results-json: ${{ needs.prepare-promotion-test-payload.outputs.results_json }}
      versions-json: ${{ needs.prepare-promotion-test-payload.outputs.versions_json }}
      system1-result: ${{ needs.frontend.result }}
      tests-status: ${{ needs.frontend.result }}
      lint-status: ${{ needs.frontend.result }}
      security-status: ${{ needs.frontend.result }}
      sonar-status: ${{ needs.sonarcloud.result }}
      pipeline-result: ${{ (needs.frontend.result == 'success' || needs.frontend.result == 'skipped') && (needs.sonarcloud.result == 'success' || needs.sonarcloud.result == 'skipped') && 'success' || (needs.frontend.result == 'cancelled' || needs.sonarcloud.result == 'cancelled') && 'cancelled' || 'failure' }}
      dry-run: ${{ (github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') && inputs.dry_run == true }}
    secrets:
      PR_TOKEN: ${{ secrets.GH_PR_TOKEN }}

  create-pr-to-main:
    name: "Create PR ‚Üí Main"
    needs: [systems-config, frontend, sonarcloud, deploy-uat, active-systems, prepare-promotion-uat-payload]
    if: >-
      always() &&
      github.ref == 'refs/heads/uat' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      ((github.event_name != 'workflow_dispatch' && github.event_name != 'workflow_call') || inputs.run_promotion == true) &&
      fromJson(needs.active-systems.outputs.active_count) > 0 &&
      (needs.frontend.result == 'success' || needs.frontend.result == 'skipped') &&
      (needs.deploy-uat.result == 'success' || needs.deploy-uat.result == 'skipped')
    uses: ./.github/workflows/promotion.yml
    with:
      pipeline-kind: ${{ needs.systems-config.outputs.pipeline_mode }}
      direction: uat-to-main
      systems-json: ${{ needs.active-systems.outputs.active_systems_json }}
      deployment-urls-json: ${{ needs.prepare-promotion-uat-payload.outputs.deployment_urls_json }}
      results-json: ${{ needs.prepare-promotion-uat-payload.outputs.results_json }}
      versions-json: ${{ needs.prepare-promotion-uat-payload.outputs.versions_json }}
      system1-result: ${{ needs.frontend.result }}
      tests-status: ${{ needs.frontend.result }}
      lint-status: ${{ needs.frontend.result }}
      security-status: ${{ needs.frontend.result }}
      sonar-status: ${{ needs.sonarcloud.result }}
      pipeline-result: ${{ (needs.frontend.result == 'success' || needs.frontend.result == 'skipped') && (needs.sonarcloud.result == 'success' || needs.sonarcloud.result == 'skipped') && 'success' || (needs.frontend.result == 'cancelled' || needs.sonarcloud.result == 'cancelled') && 'cancelled' || 'failure' }}
      dry-run: ${{ (github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') && inputs.dry_run == true }}
    secrets:
      PR_TOKEN: ${{ secrets.GH_PR_TOKEN }}

  prepare-notify-prod-payload:
    name: "Prepare Notify Payload (MAIN)"
    needs: [active-systems, deploy-prod]
    if: >-
      always() &&
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      fromJson(needs.active-systems.outputs.active_count) > 0 &&
      (needs.deploy-prod.result == 'success' || needs.deploy-prod.result == 'skipped')
    runs-on: ubuntu-latest
    outputs:
      deployment_urls_json: ${{ steps.build.outputs.deployment_urls_json }}
    steps:
      - name: Build payload JSON
        id: build
        env:
          SYSTEMS_JSON: ${{ needs.active-systems.outputs.active_systems_json }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          RESPONSE=$(curl -sS -H "Authorization: Bearer ${VERCEL_TOKEN}" "https://api.vercel.com/v6/deployments?target=production&meta-githubCommitSha=${COMMIT_SHA}&limit=100")
          if ! echo "${RESPONSE}" | jq -e . >/dev/null 2>&1; then
            RESPONSE='{"deployments":[]}'
          fi

          DEPLOYMENT_URLS_JSON=$(echo "${SYSTEMS_JSON}" | jq -c --argjson data "${RESPONSE}" --arg runUrl "${RUN_URL}" '
            reduce .[] as $s ({};
              ($s.name // "") as $name |
              ($s.dir // "" | gsub("^\\./"; "") | split("/")[0]) as $dirKey |
              ($name | ascii_downcase) as $nameLower |
              ($dirKey | ascii_downcase) as $dirLower |
              .[$name] = (
                [ $data.deployments[]?
                  | select((.state // "") == "READY")
                  | { n: ((.name // "") | ascii_downcase), u: (if (.url // "") == "" then "" else ("https://" + .url) end) }
                  | select(.u != "")
                  | select(.n == $nameLower or .n == $dirLower)
                  | .u
                ] | first // $runUrl
              )
            )
          ')

          echo "deployment_urls_json=${DEPLOYMENT_URLS_JSON}" >> "$GITHUB_OUTPUT"

  pipeline-summary:
    name: "Pipeline Summary"
    needs: [systems-config, frontend, active-systems]
    if: always()
    uses: ./.github/workflows/pipeline-summary.yml
    with:
      pipeline-kind: ${{ needs.systems-config.outputs.pipeline_mode }}
      systems-json: ${{ needs.active-systems.outputs.active_systems_json }}
      results-json: '{}'
      overall-result: ${{ needs.frontend.result }}

  auto-revert-on-failure:
    name: "Auto Revert on Failure"
    needs:
      [
        systems-config,
        active-systems,
        frontend,
        sonarcloud,
        version-test,
        deploy-test,
        deploy-uat,
        production-gate,
        deploy-prod,
        update-about-link,
        version-main-release,
        docker-main,
        prepare-promotion-test-payload,
        prepare-promotion-uat-payload,
        create-pr-to-uat,
        create-pr-to-main,
        pipeline-summary,
      ]
    if: >-
      always() &&
      github.event_name == 'push' &&
      github.repository != 'ImplementSprint/CICD-Fe-Multi' && github.repository != 'ImplementSprint/central-workflow' &&
      contains(needs.*.result, 'failure') &&
      !contains(github.event.head_commit.message, '[skip-revert]') &&
      !contains(github.event.head_commit.message, '[skip ci]') &&
      !contains(github.event.head_commit.message, '[ci skip]') &&
      !startsWith(github.event.head_commit.message, 'Revert "')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ github.token }}

      - name: Create rollback commit
        env:
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git fetch origin "${BRANCH_NAME}" --depth=50
          git checkout -B "${BRANCH_NAME}" "origin/${BRANCH_NAME}"

          export GIT_EDITOR=:

          if git revert --no-edit "${GITHUB_SHA}"; then
            git commit --amend -m "$(git log -1 --pretty=%B) [skip ci] [skip-revert]"
            echo "‚úÖ Created revert commit from ${GITHUB_SHA}."
          elif git revert -m 1 --no-edit "${GITHUB_SHA}"; then
            git commit --amend -m "$(git log -1 --pretty=%B) [skip ci] [skip-revert]"
            echo "‚úÖ Created merge-revert commit from ${GITHUB_SHA}."
          else
            git revert --abort || true
            SHORT_SHA="${GITHUB_SHA:0:7}"
            git commit --allow-empty -m "ci(auto-revert): manual rollback required for ${SHORT_SHA} [skip ci] [skip-revert]"
            echo "‚ö†Ô∏è Automatic revert conflicted; created marker commit for manual rollback."
          fi

          git push origin "HEAD:${BRANCH_NAME}"

  notify-pipeline:
    name: "Notify Pipeline Status"
    needs: [systems-config, pipeline-summary, frontend, active-systems, auto-revert-on-failure, prepare-promotion-test-payload, prepare-promotion-uat-payload, prepare-notify-prod-payload]
    if: always()
    uses: ./.github/workflows/notifications.yml
    with:
      status: ${{ (needs.frontend.result == 'success' || needs.frontend.result == 'skipped') && 'success' || (needs.frontend.result == 'cancelled' && 'cancelled' || 'failure') }}
      system-dir: ${{ needs.active-systems.outputs.active_label }}
      pipeline-type: ${{ needs.systems-config.outputs.pipeline_mode == 'single' && 'FE Single Master' || 'FE Multi Master' }}
      error-details: ${{ needs.frontend.result != 'success' && needs.frontend.result != 'skipped' && (needs.systems-config.outputs.pipeline_mode == 'single' && 'Master FE single pipeline reported failures.' || 'Master FE multi pipeline reported failures.') || '' }}
      deployment-url: ''
      deployment-urls-json: ${{ github.ref_name == 'main' && needs.prepare-notify-prod-payload.outputs.deployment_urls_json || (github.ref_name == 'uat' && needs.prepare-promotion-uat-payload.outputs.deployment_urls_json || (github.ref_name == 'test' && needs.prepare-promotion-test-payload.outputs.deployment_urls_json || '{}')) }}
      success-image-url: ${{ vars.JED_SUCCESS_IMAGE_URL }}
      failure-image-url: ${{ vars.JED_FAIL_IMAGE_URL }}
      cancelled-image-url: ${{ vars.JED_CANCELLED_IMAGE_URL }}
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
